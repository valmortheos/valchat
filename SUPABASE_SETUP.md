# Panduan Konfigurasi Database & Supabase (Auth Biasa)

Panduan ini diperbarui untuk menggunakan autentikasi **Email & Password** standar sesuai permintaan.

## 1. Setup Auth (WAJIB)

Agar login/register berfungsi lancar tanpa verifikasi email yang ribet:

1.  Masuk ke Supabase Dashboard.
2.  Pilih Project Anda.
3.  Buka menu **Authentication** -> **Providers**.
4.  Pilih **Email**.
5.  Pastikan **Enable Email provider** aktif.
6.  **PENTING**: Matikan opsi **Confirm email** (Nonaktifkan) agar user bisa langsung login setelah daftar tanpa perlu buka inbox email.
7.  Simpan.

## 2. Setup Database (Copy & Paste ke SQL Editor Supabase)

Jalankan script ini di menu **SQL Editor**. Script ini mencakup Trigger Otomatis profil, dan tabel Arsip Pesan.

```sql
-- 1. FUNGSI UPDATE TIMESTAMP (Untuk profiles.updated_at)
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. Buat/Pastikan Tabel Profiles Ada & Pasang Trigger
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  updated_at TIMESTAMP WITH TIME ZONE,
  username TEXT UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  bio TEXT,
  email TEXT,
  last_seen TIMESTAMP WITH TIME ZONE DEFAULT now()
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Pasang Trigger updated_at pada profiles
DROP TRIGGER IF EXISTS on_profiles_updated ON public.profiles;
CREATE TRIGGER on_profiles_updated
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- Reset Policy
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;

CREATE POLICY "Public profiles are viewable by everyone." 
  ON public.profiles FOR SELECT USING (true);

CREATE POLICY "Users can insert their own profile." 
  ON public.profiles FOR INSERT 
  WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile." 
  ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- 3. FUNGSI & TRIGGER AUTH HANDLER
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, username, avatar_url)
  VALUES (
    new.id,
    new.email,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'username',
    COALESCE(new.raw_user_meta_data->>'avatar_url', 'https://ui-avatars.com/api/?background=2AABEE&color=fff&bold=true&name=' || new.email)
  )
  ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    username = EXCLUDED.username;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 4. Tabel Pesan (Messages)
CREATE TABLE IF NOT EXISTS public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  content TEXT,
  user_id UUID REFERENCES public.profiles(id),
  user_email TEXT,
  user_avatar TEXT,
  receiver_id UUID REFERENCES public.profiles(id),
  room_id TEXT NOT NULL,
  file_url TEXT,
  file_type TEXT,
  is_deleted BOOLEAN DEFAULT false
);

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Messages are viewable by everyone in the room" ON public.messages;
DROP POLICY IF EXISTS "Users can insert their own messages" ON public.messages;
DROP POLICY IF EXISTS "Users can update (delete) their own messages" ON public.messages;
DROP POLICY IF EXISTS "Users can delete their own messages" ON public.messages;

CREATE POLICY "Messages are viewable by everyone in the room" 
  ON public.messages FOR SELECT 
  USING (
    room_id = 'public' OR 
    auth.uid() = user_id OR 
    auth.uid() = receiver_id
  );

CREATE POLICY "Users can insert their own messages" 
  ON public.messages FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update (delete) their own messages" 
  ON public.messages FOR UPDATE 
  USING (auth.uid() = user_id);

-- Policy untuk HARD DELETE
CREATE POLICY "Users can delete their own messages" 
  ON public.messages FOR DELETE 
  USING (auth.uid() = user_id);

-- 5. Tabel Read Receipts
CREATE TABLE IF NOT EXISTS public.read_receipts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  message_id BIGINT REFERENCES public.messages(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  read_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(message_id, user_id)
);

ALTER TABLE public.read_receipts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can insert/update their own read receipts" ON public.read_receipts;
DROP POLICY IF EXISTS "Read receipts are viewable by everyone" ON public.read_receipts;

CREATE POLICY "Users can insert/update their own read receipts"
  ON public.read_receipts FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Read receipts are viewable by everyone"
  ON public.read_receipts FOR SELECT
  USING (true);

-- 6. Tabel Deleted Messages (Hanya untuk fitur 'Delete for Me')
CREATE TABLE IF NOT EXISTS public.deleted_messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  message_id BIGINT REFERENCES public.messages(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  deleted_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

ALTER TABLE public.deleted_messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can insert their own deleted messages" ON public.deleted_messages;
DROP POLICY IF EXISTS "Users can view their own deleted messages" ON public.deleted_messages;

CREATE POLICY "Users can insert their own deleted messages"
  ON public.deleted_messages FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view their own deleted messages"
  ON public.deleted_messages FOR SELECT
  USING (auth.uid() = user_id);

-- 7. Tabel Message Archives (BARU: Untuk 'Delete for Everyone')
-- Tabel ini menyimpan pesan yang sudah dihapus permanen dari tabel messages
CREATE TABLE IF NOT EXISTS public.message_archives (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  original_message_id BIGINT,
  content TEXT,
  file_url TEXT,
  user_id UUID,
  room_id TEXT,
  archived_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

ALTER TABLE public.message_archives ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can insert archives" ON public.message_archives;
CREATE POLICY "Users can insert archives" 
  ON public.message_archives FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

-- 8. View Last Messages
CREATE OR REPLACE VIEW public.last_messages AS
SELECT DISTINCT ON (room_id) *
FROM public.messages
ORDER BY room_id, created_at DESC;

-- 9. Storage Buckets
INSERT INTO storage.buckets (id, name, public) VALUES ('avatars', 'avatars', true) ON CONFLICT DO NOTHING;
INSERT INTO storage.buckets (id, name, public) VALUES ('chat-files', 'chat-files', true) ON CONFLICT DO NOTHING;

DROP POLICY IF EXISTS "Avatar Images Public" ON storage.objects;
DROP POLICY IF EXISTS "Avatar Upload Auth" ON storage.objects;
DROP POLICY IF EXISTS "Chat Files Public" ON storage.objects;
DROP POLICY IF EXISTS "Chat Files Upload Auth" ON storage.objects;
DROP POLICY IF EXISTS "Chat Files Delete Auth" ON storage.objects;

CREATE POLICY "Avatar Images Public" ON storage.objects FOR SELECT USING (bucket_id = 'avatars');
CREATE POLICY "Avatar Upload Auth" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'avatars' AND auth.role() = 'authenticated');
CREATE POLICY "Chat Files Public" ON storage.objects FOR SELECT USING (bucket_id = 'chat-files');
CREATE POLICY "Chat Files Upload Auth" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'chat-files' AND auth.role() = 'authenticated');
-- Penting: Izin Delete untuk membersihkan file saat hard delete
CREATE POLICY "Chat Files Delete Auth" ON storage.objects FOR DELETE USING (bucket_id = 'chat-files' AND auth.role() = 'authenticated');
```